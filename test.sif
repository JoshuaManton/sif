#c_code "
void print_int(int i) {
    printf(\"%%d\\\n\", i);
}
void print_float(float f) {
    printf(\"%%f\\\n\", f);
}
void print(String string) {
    for (int i = 0; i < string.count; i++) {
        char c = string.data[i];
        printf(\"%%c\", c);
    }
    printf(\"\\\n\");
}
char *alloc(int size) {
    char *memory = (char *)malloc(size);
    return memory;
}
void assert(bool condition) {
    if (!condition) {
        printf(\"Assertion failed.\");
        *((char *)0) = 0;
    }
}
"

proc print_int(var i: i32) #foreign;
proc print_float(var f: f32) #foreign;
proc print(var str: string) #foreign;
proc alloc(var size: int) : rawptr #foreign;
proc free(var ptr: rawptr) #foreign;
proc assert(var condition: bool) #foreign;

struct Vector3 {
    const WOW_A_CONSTANT = 123;
    var x: float;
    var y: float;
    var z: float;
}

#assert("foo" == "foo");
#assert("foo" != "bar");
#assert("foo" != "foobar");
#assert("foobar" != "foo");
#assert(("foo" + "bar") == "foobar");

proc main() {
    const N = 16;
    #assert(N == 16);
    const My_Int_Type = int;
    const MY_INT: My_Int_Type = 321;
    var my_int = MY_INT;
    #assert(typeof(my_int) == My_Int_Type);

    var value = 0;
    while (value < 10) {
        print_int(cast(i32, value));
        value = value + 1;
    }

    // todo(josh)
    // print_int(Vector3.WOW_A_CONSTANT);

    var memory = cast(^Vector3, alloc(sizeof(Vector3) * N));
    var slice: []Vector3;
    slice.data = memory;
    slice.count = N;
    for (var i = 0; i < slice.count; i = i + 1) {
        var v = &slice[i];
        v.x = 9;
        v.y = 4;
        v.z = 1;
    }

    print("Hello, " + "World!");

    var v_in_slice = slice[9];
    print_float(v_in_slice.x);
    print_float(v_in_slice.y);
    print_float(v_in_slice.z);

    var v_ptr = cast(^Vector3, alloc(sizeof(Vector3)));
    v_ptr.x = 1;
    v_ptr.y = 4;
    v_ptr.z = 9;
    print_float(v_ptr.x);
    print_float(v_ptr.y);
    print_float(v_ptr.z);
    free(v_ptr);

    var str = "Hello, " + "World";
    print(str);
    print_int(cast(i32, "asd123".count));

    var arr: [3]int;
    arr[0] = 1;
    arr[1] = 4;
    arr[2] = 9;
    for (var i = 0; i < arr.count; i = i + 1) {
        print_int(cast(i32, arr[i]));
    }
    var v: Vector3;
    v.x = 1.5;
    v.y = 4.4;
    v.z = 9.3;
    print_float(v.x);
    print_float(v.y);
    print_float(v.z);

    var neato: [v.WOW_A_CONSTANT]bool;
    #assert(sizeof(typeof(neato)) == 123);

    var a: [4]int;
    var x = (&a[2])^;
    #assert(typeof(x) == int);

    var v_ptr2 = &v;
    #assert(typeof(v_ptr2) == ^Vector3);
    v_ptr2.x = 2;
    v_ptr2.y = cast(float, return_stuff());

    var x_ptr = cast(^float, v_ptr2);
    #assert(typeof(x_ptr) == ^float);
    x_ptr^ = 149;

    if (x_ptr^ == 40) {
        return;
    }
}

proc return_stuff() : int {
    if (1 == 1) {
        return 123;
    }
    return 321;
}

var a: [sizeof(typeof(p^))]int;
var p: ^T;
struct T {
    var a: [sizeof(typeof(p))]bool;
}

struct A {
    var b: [4]B;
}
struct B {
    var a: ^A;
}

struct Contains_Pointers1 {
    var a: ^Contains_Pointers2;
}
struct Contains_Pointers2 {
    var b: ^Contains_Pointers1;
}

struct Self_Pointer {
    var b: ^Self_Pointer;
}

proc AAA() {
    var aa: A;
    var b: B = aa.b[2];

    var c: ^Contains_Pointers1;
    var d: ^Contains_Pointers2 = c.a;
    c.a = d;
    // d.b = c;

    var e: Self_Pointer;
}

var simple: int;
var pointer: ^int;
var array: [4]int;
var pointer_to_pointer: ^^int;
var array_of_arrays: [4][8]int;
var pointer_to_array: ^[4]int;
var array_of_pointers: [4]^int;
var wack: ^^[4][8]int;
var more_wack: [4][8]^^int;
var still_more_wack: ^[4]^[8]int;
var complicated_garbage: ^^[4]^[8][32]^int;

proc recursion() {
    var b: ^Some_Struct;
    var x: int = b.x;
    recursion();
}

proc duo_recursion1() {
    duo_recursion2();
}
proc duo_recursion2() {
    var a: Some_Struct;
    duo_recursion1();
}

proc baz(var x: int) {
    foo(x);
}

proc foo(var x: int) {
    bar(1);
    var b: Some_Struct;
    var z: int;
    z = 321;
}
proc bar(var x: int) {
    baz(2);
    var y: ^int;
    var z: int = y^;
    z = 123 + z;
    z = z + 123;
    z = 12 + 12;
}
var global_var: int;
struct Some_Struct {
    var x: int;
}