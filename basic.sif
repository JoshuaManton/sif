#c_code "
void print_int(i64 i) {
    printf(\"%%lld\\\n\", i);
}
void print_float(float f) {
    printf(\"%%f\\\n\", f);
}
void print_string(String string) {
    for (i64 i = 0; i < string.count; i++) {
        char c = string.data[i];
        printf(\"%%c\", c);
    }
}
void *alloc(i64 size) {
    char *memory = (char *)malloc(size);
    return memory;
}
void assert(bool condition) {
    if (!condition) {
        printf(\"Assertion failed.\");
        *((char *)0) = 0;
    }
}
"

proc print_int   (i: int)                                                #foreign;
proc print_float (f: float)                                              #foreign;
proc print_string(str: string)                                           #foreign;
proc alloc       (size: int)                                    : rawptr #foreign;
proc free        (ptr: rawptr)                                           #foreign;
proc assert      (condition: bool)                                       #foreign;
proc memcpy      (dst: rawptr, src: rawptr, size_in_bytes: u32) : rawptr #foreign;



proc slice_ptr(ptr: ^$T, count: int) : []T {
    var slice: []T;
    slice.data = ptr;
    slice.count = count;
    return slice;
}



// dynamic array implementation

struct Dynamic_Array!($T: typeid) {
    var array: []T;
    var count: int;
    operator [](dyn: >Dynamic_Array!(T), index: int) : >T {
        return dyn.array[index];
    }
}

proc append(dyn: ^Dynamic_Array!($T), value: T) {
    if (dyn.count == dyn.array.count) {
        var old_data = dyn.array.data;
        var new_cap = 8 + dyn.array.count * 2;
        dyn.array.data = cast(^T, alloc(new_cap * sizeof(T)));
        dyn.array.count = new_cap;
        if (old_data != null) {
            memcpy(dyn.array.data, old_data, cast(u32, dyn.count * sizeof(T)));
            free(old_data);
        }
    }
    assert(dyn.count < dyn.array.count);
    dyn.array[dyn.count] = value;
    dyn.count += 1;
}

proc pop(dyn: ^Dynamic_Array!($T)) : T {
    assert(dyn.count > 0);
    var value = dyn[dyn.count-1];
    dyn.count -= 1;
    return value;
}

proc clear_dynamic_array(dyn: ^Dynamic_Array!($T)) {
    dyn.count = 0;
}

proc destroy_dynamic_array(dyn: ^Dynamic_Array!($T)) {
    if (dyn.array.data != null) {
        free(dyn.array.data);
    }
}