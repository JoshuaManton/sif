proc malloc      (size: int)                                    : rawptr #foreign; @sif_runtime
proc free        (ptr: rawptr)                                           #foreign; @sif_runtime
proc assert      (condition: bool)                                       #foreign; @sif_runtime
proc memset      (ptr: rawptr, val: i32, size_in_bytes: u64)    : rawptr #foreign; @sif_runtime
proc memcpy      (dst: rawptr, src: rawptr, size_in_bytes: u64) : rawptr #foreign; @sif_runtime
proc memmove     (dst: rawptr, src: rawptr, size_in_bytes: u64) : rawptr #foreign; @sif_runtime



proc zero_pointer(ptr: rawptr, size_in_bytes: int) {
    memset(ptr, 0, cast(u64, size_in_bytes));
} @sif_runtime

proc zero_memory(memory: []byte) {
    zero_pointer(memory.data, memory.count);
} @sif_runtime



proc ptr_offset(ptr: ^$T, offset_in_bytes: int) : ^T {
    var ptr_int = transmute(u64, ptr);
    ptr_int += cast(u64, offset_in_bytes);
    return transmute(^T, ptr_int);
} @sif_runtime



proc slice_ptr(ptr: ^$T, count: int) : []T {
    var slice: []T;
    slice.data = ptr;
    slice.count = count;
    return slice;
} @sif_runtime

proc string_ptr(ptr: ^u8, count: int) : string {
    var str: string;
    str.data = ptr;
    str.count = count;
    return str;
} @sif_runtime



proc to_slice(arr: ^[$N]$E) : []E {
    var slice: []E;
    slice.data = &arr^[0];
    slice.count = N;
    return slice;
}



struct Raw_Slice {
    var data: rawptr;
    var count: int;
} @sif_runtime

struct Raw_String {
    var data: rawptr;
    var count: int;
} @sif_runtime



struct Allocator {
    var data: rawptr;
    var alloc_proc: proc(allocator: rawptr, size: int, align: int) : rawptr;
    var free_proc:  proc(allocator: rawptr, ptr: rawptr);
} @sif_runtime

proc sif_alloc(size: int, align: int, allocator: Allocator) : rawptr {
    assert(allocator.alloc_proc != null);
    return allocator.alloc_proc(allocator.data, size, align);
} @sif_runtime

proc sif_free(ptr: rawptr, allocator: Allocator) {
    assert(allocator.free_proc != null);
    allocator.free_proc(allocator.data, ptr);
} @sif_runtime



proc default_allocator_alloc(allocator: rawptr, size: int, align: int) : rawptr {
    return malloc(size);
} @sif_runtime
proc default_allocator_free(allocator: rawptr, ptr: rawptr) {
    free(ptr);
} @sif_runtime
proc default_allocator() : Allocator {
    var a: Allocator;
    a.alloc_proc = default_allocator_alloc;
    a.free_proc = default_allocator_free;
    return a;
} @sif_runtime



proc string_eq(var a: string, var b: string) : bool {
    if (a.count != b.count) {
        return false;
    }
    for (var i = 0; i < a.count; i += 1) {
        if (a[i] != b[i]) {
            return false;
        }
    }
    return true;
} @sif_runtime



union Union_All_Type_Infos {
    var type_info:              Type_Info;
    var type_info_integer:      Type_Info_Integer;
    var type_info_float:        Type_Info_Float;
    var type_info_bool:         Type_Info_Bool;
    var type_info_string:       Type_Info_String;
    var type_info_struct_field: Type_Info_Struct_Field;
    var type_info_struct:       Type_Info_Struct;
    var type_info_union:        Type_Info_Union;
    var type_info_enum_field:   Type_Info_Enum_Field;
    var type_info_enum:         Type_Info_Enum;
    var type_info_pointer:      Type_Info_Pointer;
    var type_info_slice:        Type_Info_Slice;
    var type_info_array:        Type_Info_Array;
    var type_info_reference:    Type_Info_Reference;
    var type_info_procedure:    Type_Info_Procedure;
    var type_info_typeid:       Type_Info_Typeid;
} @sif_runtime

var _global_type_table: []Union_All_Type_Infos; @sif_runtime

proc get_type_info(type: typeid) : ^Type_Info {
    var idx = transmute(u64, type);
    assert(transmute(u64, type) > 0);
    assert(transmute(u64, type) < cast(u64, _global_type_table.count));
    return cast(^Type_Info, &_global_type_table[cast(int, idx)]);
} @sif_runtime

// note(josh): backend depends on this ordering! :TypeInfoKindValues
enum Type_Info_Kind {
    INTEGER   = 0;
    FLOAT     = 1;
    BOOL      = 2;
    STRING    = 3;
    STRUCT    = 4;
    UNION     = 5;
    ENUM      = 6;
    POINTER   = 7;
    SLICE     = 8;
    ARRAY     = 9;
    REFERENCE = 10;
    PROCEDURE = 11;
    TYPEID    = 12;
} @sif_runtime

struct Type_Info {
    var printable_name: string;
    var kind: Type_Info_Kind;
    var id: typeid;
    var size: int;
    var align: int;
} @sif_runtime

struct Type_Info_Integer {
    var base: Type_Info;
    var is_signed: bool;
} @sif_runtime

struct Type_Info_Float {
    var base: Type_Info;
} @sif_runtime

struct Type_Info_Bool {
    var base: Type_Info;
} @sif_runtime

struct Type_Info_String {
    var base: Type_Info;
} @sif_runtime

struct Type_Info_Struct_Field {
    var name: string;
    var type: ^Type_Info;
    var offset: int;
} @sif_runtime
struct Type_Info_Struct {
    var base: Type_Info;
    var name: string;
    var fields: []Type_Info_Struct_Field;
} @sif_runtime

struct Type_Info_Union {
    var base: Type_Info;
    var name: string;
    var fields: []Type_Info_Struct_Field;
} @sif_runtime

struct Type_Info_Enum_Field {
    var name: string;
    var value: int;
} @sif_runtime
struct Type_Info_Enum {
    var base: Type_Info;
    var base_type: ^Type_Info;
    var fields: []Type_Info_Enum_Field;
} @sif_runtime

struct Type_Info_Pointer {
    var base: Type_Info;
    var pointer_to: ^Type_Info;
} @sif_runtime

struct Type_Info_Slice {
    var base: Type_Info;
    var slice_of: ^Type_Info;
} @sif_runtime

struct Type_Info_Array {
    var base: Type_Info;
    var array_of: ^Type_Info;
    var count: int;
} @sif_runtime

struct Type_Info_Reference {
    var base: Type_Info;
    var reference_to: ^Type_Info;
} @sif_runtime

struct Type_Info_Procedure {
    var base: Type_Info;
    var parameter_types: []^Type_Info;
    var return_type: ^Type_Info;
} @sif_runtime

struct Type_Info_Typeid {
    var base: Type_Info;
} @sif_runtime