#include "core:basic.sif"

struct Dynamic_Array!($T: typeid) {
    var elements: []T;
    var count: int;
    var allocator: Allocator;
    operator [](dyn: >Dynamic_Array!(T), index: int) : >T {
        return dyn.elements[index];
    }
}

proc append(dyn: ^Dynamic_Array!($T), value: T) : ^T {
    assert(dyn.allocator.alloc_proc != null);
    if (dyn.count == dyn.elements.count) {
        var old_data = dyn.elements.data;
        var new_cap = 8 + dyn.elements.count * 2;
        dyn.elements.data = cast(^T, sif_alloc(new_cap * sizeof(T), DEFAULT_ALIGNMENT, dyn.allocator));
        dyn.elements.count = new_cap;
        if (old_data != null) {
            memcpy(dyn.elements.data, old_data, cast(u64, dyn.count * sizeof(T)));
            sif_free(old_data, dyn.allocator);
        }
    }
    assert(dyn.count < dyn.elements.count);
    dyn.elements[dyn.count] = value;
    var ptr = &dyn.elements[dyn.count];
    dyn.count += 1;
    return ptr;
}

proc append_empty(dyn: ^Dynamic_Array!($T)) : ^T {
    var t: T;
    return append(dyn, t);
}

proc pop(dyn: ^Dynamic_Array!($T)) : T {
    assert(dyn.count > 0);
    var value = dyn[dyn.count-1];
    dyn.count -= 1;
    return value;
}

proc unordered_remove(dyn: ^Dynamic_Array!($T), index: int) : T {
    var value = dyn^[index];
    dyn^[index] = dyn^[dyn.count-1];
    dyn.count -= 1;
    return value;
}

proc ordered_remove(dyn: ^Dynamic_Array!($T), index: int) : T {
    var value = dyn^[index];
    if (index != dyn.count-1) {
        var src: rawptr = &dyn^[index+1];
        var dst: rawptr = &dyn^[index];
        memmove(dst, src, cast(u64, (dyn.count-index+1) * sizeof(T)));
    }
    dyn.count -= 1;
    return value;
}

proc clear_dynamic_array(dyn: ^Dynamic_Array!($T)) {
    dyn.count = 0;
}

proc destroy_dynamic_array(dyn: Dynamic_Array!($T)) {
    if (dyn.elements.data != null) {
        sif_free(dyn.elements.data, dyn.allocator);
    }
}